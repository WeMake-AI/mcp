---
description: Remote MCP server deployment and testing on Cloudflare Workers
---

# Remote MCP Server Deployment Standards

## Overview

This rule defines patterns for deploying MCP servers as Remote MCP servers on Cloudflare Workers with SSE (Server-Sent
Events) transport, OAuth authentication, and comprehensive testing workflows.

Remote MCP servers enable multi-user production deployments accessible over HTTP/HTTPS, unlike local stdio-based servers
which run as local processes.

## Remote vs Local Transport

### Local MCP Servers (stdio)

Current implementation in this monorepo:

```typescript
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";

const transport = new StdioServerTransport();
await server.connect(transport);
```

**Characteristics**:

- Process-based communication (stdin/stdout)
- Single user per instance
- Local development and testing
- Configured in Claude Desktop / Cursor as command-line tools
- No authentication required (runs in user's context)

### Remote MCP Servers (SSE)

Production deployment pattern:

```typescript
import { SSEServerTransport } from "@modelcontextprotocol/sdk/server/sse.js";

export default {
  async fetch(request: Request, env: Env): Promise<Response> {
    const url = new URL(request.url);

    if (url.pathname === "/sse") {
      const transport = new SSEServerTransport("/messages", response);
      await server.connect(transport);
      return transport.response;
    }

    return new Response("Not Found", { status: 404 });
  }
};
```

**Characteristics**:

- HTTP/SSE-based communication
- Multi-user support with authentication
- Production-ready deployment
- Accessible from any MCP client over network
- OAuth-based authentication and authorization
- Scalable and distributed

### When to Use Remote Servers

Use Remote MCP servers for:

- **Production deployments**: Enterprise environments requiring high availability
- **Multi-user scenarios**: Team collaboration with shared tools
- **Cross-platform access**: Accessible from web, desktop, mobile clients
- **Managed authentication**: OAuth integration with enterprise identity providers
- **Scalability**: Cloudflare Workers global distribution
- **GDPR compliance**: Centralized audit logging and data governance

## Server Structure for Remote MCP

### Basic Remote MCP Server (Without Authentication)

Template: `cloudflare/ai/demos/remote-mcp-authless`

```typescript
import { Server } from "@modelcontextprotocol/sdk/server/index.js";
import { SSEServerTransport } from "@modelcontextprotocol/sdk/server/sse.js";

interface Env {
  // Environment variables and bindings
}

export default {
  async fetch(request: Request, env: Env): Promise<Response> {
    const url = new URL(request.url);

    // SSE endpoint for MCP communication
    if (url.pathname === "/sse") {
      const server = new Server({ name: "my-mcp-server", version: "1.0.0" }, { capabilities: { tools: {} } });

      // Register tool handlers
      server.setRequestHandler(ListToolsRequestSchema, async () => ({
        tools: [
          {
            name: "my_tool",
            description: "Tool description",
            inputSchema: {
              type: "object",
              properties: {
                param: { type: "string" }
              },
              required: ["param"]
            }
          }
        ]
      }));

      server.setRequestHandler(CallToolRequestSchema, async (request) => {
        // Handle tool calls
        return {
          content: [{ type: "text", text: "Result" }]
        };
      });

      const transport = new SSEServerTransport("/messages", request);
      await server.connect(transport);

      return transport.response;
    }

    return new Response("Not Found", { status: 404 });
  }
};
```

### Remote MCP Server with OAuth Authentication

Template: `cloudflare/ai/demos/remote-mcp-github-oauth`

```typescript
import { OAuthProvider } from "@modelcontextprotocol/server-oauth";
import GitHubHandler from "./github-handler";

interface Env {
  GITHUB_CLIENT_ID: string;
  GITHUB_CLIENT_SECRET: string;
}

export default new OAuthProvider({
  apiRoute: "/sse",
  apiHandler: MyMCP.Router,
  defaultHandler: GitHubHandler,
  authorizeEndpoint: "/authorize",
  tokenEndpoint: "/token",
  clientRegistrationEndpoint: "/register"
});
```

**OAuth Endpoints**:

- `/sse` - Server-Sent Events endpoint for MCP communication
- `/authorize` - OAuth authorization endpoint (redirects to OAuth provider)
- `/token` - OAuth token exchange endpoint
- `/register` - Client registration endpoint
- `/callback` - OAuth callback handler (redirect URI)

## OAuth Authentication Patterns

### GitHub OAuth Setup

#### Step 1: Create OAuth Apps

Create **two** GitHub OAuth Apps at [github.com/settings/developers](https://github.com/settings/developers):

**Development OAuth App**:

- Application name: `My MCP Server (local)`
- Homepage URL: `http://localhost:8787`
- Authorization callback URL: `http://localhost:8787/callback`

**Production OAuth App**:

- Application name: `My MCP Server (production)`
- Homepage URL: `https://your-worker.your-account.workers.dev`
- Authorization callback URL: `https://your-worker.your-account.workers.dev/callback`

#### Step 2: Configure Environment Variables

**Local Development** (`.dev.vars`):

```env
GITHUB_CLIENT_ID="dev-client-id-here"
GITHUB_CLIENT_SECRET="dev-client-secret-here"
```

**Production** (Wrangler secrets):

```sh
bunx wrangler secret put GITHUB_CLIENT_ID
bunx wrangler secret put GITHUB_CLIENT_SECRET
```

#### Step 3: Environment Interface

```typescript
export interface Env {
  // OAuth credentials
  GITHUB_CLIENT_ID: string;
  GITHUB_CLIENT_SECRET: string;

  // Optional: Other providers
  GOOGLE_CLIENT_ID?: string;
  GOOGLE_CLIENT_SECRET?: string;

  // Cloudflare bindings
  DB?: D1Database;
  KV?: KVNamespace;
}
```

### Alternative OAuth Providers

The OAuth provider pattern supports multiple identity providers:

- **Google**: Enterprise G Suite integration
- **Auth0**: Unified identity management
- **WorkOS**: Enterprise SSO (SAML, OIDC)
- **Stytch**: Passwordless authentication
- **Slack**: Team-based authentication
- **Microsoft**: Azure AD integration

Example with multiple providers:

```typescript
import GoogleHandler from "./google-handler";
import Auth0Handler from "./auth0-handler";

const oauthProvider = new OAuthProvider({
  apiRoute: "/sse",
  apiHandler: MyMCP.Router,

  // Select provider based on request or environment
  defaultHandler: process.env.OAUTH_PROVIDER === "google" ? GoogleHandler : GitHubHandler,

  authorizeEndpoint: "/authorize",
  tokenEndpoint: "/token",
  clientRegistrationEndpoint: "/register"
});
```

### Human-in-the-Loop Authorization

For sensitive operations, implement authorization checks:

```typescript
server.setRequestHandler(CallToolRequestSchema, async (request, extra) => {
  const { name, arguments: args } = request.params;

  // Extract user context from OAuth session
  const userContext = extra?.context?.user;

  if (name === "delete_data") {
    // Verify user has permission
    if (!userContext?.permissions?.includes("delete")) {
      throw new Error("Insufficient permissions for delete operation");
    }

    // Log for audit trail (GDPR compliance)
    await logOperation({
      user: userContext.id,
      action: "delete_data",
      timestamp: new Date().toISOString(),
      args: args
    });
  }

  // Process tool call
  return processToolCall(name, args);
});
```

## Wrangler Configuration for Remote MCP

### Basic wrangler.toml

Create `wrangler.toml` in the server package directory:

```toml
name = "mcp-server-name"
main = "dist/index.js"
compatibility_date = "2024-01-01"
node_compat = true

# Workers settings
workers_dev = true
route = ""
zone_id = ""

# Build configuration
[build]
command = "bun run build"

# Environment: Development
[env.development]
name = "mcp-server-name-dev"
vars = { ENVIRONMENT = "development" }

# Environment: Production
[env.production]
name = "mcp-server-name-production"
vars = { ENVIRONMENT = "production" }
```

### Advanced Configuration with Bindings

```toml
name = "mcp-decision-framework"
main = "dist/worker.js"
compatibility_date = "2024-01-01"

# D1 Database binding for persistent storage
[[d1_databases]]
binding = "DB"
database_name = "mcp_decisions"
database_id = "your-d1-database-id"

# KV binding for session storage
[[kv_namespaces]]
binding = "SESSIONS"
id = "your-kv-namespace-id"

# R2 binding for file storage
[[r2_buckets]]
binding = "FILES"
bucket_name = "mcp-files"

# Durable Objects for stateful operations
[[durable_objects.bindings]]
name = "DECISION_STATE"
class_name = "DecisionDurableObject"

# Analytics Engine binding
[[analytics_engine_datasets]]
binding = "ANALYTICS"
```

### Environment Variables Strategy

**Public configuration** (in `wrangler.toml`):

```toml
[env.production.vars]
MAX_SESSIONS = "1000"
ENABLE_LOGGING = "true"
RATE_LIMIT_PER_HOUR = "100"
```

**Secrets** (via CLI, NEVER in version control):

```sh
# Set secrets for production
bunx wrangler secret put GITHUB_CLIENT_ID --env production
bunx wrangler secret put GITHUB_CLIENT_SECRET --env production
bunx wrangler secret put API_ENCRYPTION_KEY --env production

# Set secrets for development
bunx wrangler secret put GITHUB_CLIENT_ID --env development
bunx wrangler secret put GITHUB_CLIENT_SECRET --env development
```

**Local development** (`.dev.vars` file, add to `.gitignore`):

```env
GITHUB_CLIENT_ID=local-dev-client-id
GITHUB_CLIENT_SECRET=local-dev-client-secret
API_ENCRYPTION_KEY=local-encryption-key
```

## Testing Patterns

### Local Testing with MCP Inspector

#### Step 1: Start Development Server

```sh
# Navigate to server directory
cd src/decision-framework

# Start local development server (Bun-first)
bun run dev

# Or use wrangler directly
bunx wrangler dev
```

Server runs at: `http://localhost:8787/sse`

#### Step 2: Launch MCP Inspector

In a new terminal:

```sh
bunx @modelcontextprotocol/inspector@latest
```

Inspector opens at: `http://localhost:5173`

#### Step 3: Connect and Test

1. Enter server URL: `http://localhost:8787/sse`
2. Click **Connect**
3. If OAuth is enabled, complete authentication flow
4. Click **List Tools** to see available tools
5. Select a tool and test with sample inputs
6. Verify responses and error handling

#### Step 4: Debug with Inspector

The inspector provides:

- Real-time request/response logging
- JSON schema validation
- Tool input/output inspection
- Connection status monitoring
- Error message details

### Production Testing

#### Deploy to Workers

```sh
# Build for production
bun run build

# Deploy to Cloudflare Workers
bunx wrangler deploy --env production

# View deployment URL
bunx wrangler deployments list
```

Deployed URL format: `https://mcp-server-name-production.your-account.workers.dev/sse`

#### Test with MCP Inspector

1. Open MCP Inspector: `http://localhost:5173`
2. Enter production URL: `https://your-worker.workers.dev/sse`
3. Complete OAuth flow (if enabled)
4. Test all tools in production environment
5. Verify OAuth token persistence
6. Test error handling and rate limiting

#### Monitoring and Logs

```sh
# View real-time logs
bunx wrangler tail --env production

# View deployment history
bunx wrangler deployments list

# View analytics
bunx wrangler pages deployment list
```

### Testing with Claude Desktop

Configure Claude Desktop to use remote MCP server via `mcp-remote` proxy.

**macOS**: `~/Library/Application Support/Claude/claude_desktop_config.json` **Windows**:
`%APPDATA%\Claude\claude_desktop_config.json`

```json
{
  "mcpServers": {
    "decision-framework": {
      "command": "bunx",
      "args": ["mcp-remote", "https://mcp-decision-framework.your-account.workers.dev/sse"]
    },
    "memory": {
      "command": "bunx",
      "args": ["mcp-remote", "https://mcp-memory.your-account.workers.dev/sse"]
    }
  }
}
```

**Restart Claude Desktop** after configuration changes.

Test by asking Claude to use your tools:

- "Use the decision framework to analyze buying vs renting"
- "Store this information in memory: [data]"

### Testing with Cursor

Cursor MCP configuration: `.cursor/mcp.json` (workspace root)

```json
{
  "mcpServers": {
    "decision-framework": {
      "command": "bunx mcp-remote https://mcp-decision-framework.your-account.workers.dev/sse"
    }
  }
}
```

**Note**: Cursor combines command and args into a single string.

### Testing with Windsurf

Windsurf MCP configuration: `mcp_config.json`

```json
{
  "mcpServers": {
    "decision-framework": {
      "command": "bunx",
      "args": ["mcp-remote", "https://mcp-decision-framework.your-account.workers.dev/sse"]
    }
  }
}
```

## Build and Deployment Pipeline

### Build Configuration

Update `package.json` in each server package:

```json
{
  "name": "@wemake/mcp-server-name",
  "version": "1.0.0",
  "scripts": {
    "dev": "wrangler dev",
    "build": "bun build src/index.ts --outfile=dist/index.js --target=browser --format=esm",
    "deploy": "wrangler deploy --env production",
    "deploy:dev": "wrangler deploy --env development"
  }
}
```

**Critical**: Use `--target=browser` for Workers compatibility.

### Single-File Bundle Requirement

Workers require single-file bundles with all dependencies inlined:

```sh
# Build Workers-compatible bundle
bun build src/index.ts \
  --outfile=dist/worker.js \
  --target=browser \
  --format=esm \
  --minify \
  --sourcemap
```

### GitHub Actions Deployment

Create `.github/workflows/deploy-mcp-servers.yml`:

```yaml
name: Deploy MCP Servers to Cloudflare Workers

on:
  push:
    branches:
      - main
  workflow_dispatch:

jobs:
  deploy:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        server:
          - decision-framework
          - memory
          - scientific-method
          - collaborative-reasoning

    steps:
      - uses: actions/checkout@v4

      - uses: oven-sh/setup-bun@v2
        with:
          bun-version: "1.2.0"

      - name: Install dependencies
        run: bun install --frozen-lockfile

      - name: Build ${{ matrix.server }}
        run: |
          cd src/${{ matrix.server }}
          bun run build

      - name: Deploy ${{ matrix.server }} to Cloudflare Workers
        uses: cloudflare/wrangler-action@v3
        with:
          apiToken: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          accountId: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          workingDirectory: src/${{ matrix.server }}
          command: deploy --env production

      - name: Configure secrets
        run: |
          cd src/${{ matrix.server }}
          echo "${{ secrets.GITHUB_CLIENT_ID }}" | bunx wrangler secret put GITHUB_CLIENT_ID --env production
          echo "${{ secrets.GITHUB_CLIENT_SECRET }}" | bunx wrangler secret put GITHUB_CLIENT_SECRET --env production
```

### Environment Variable Injection in CI/CD

Configure secrets in GitHub repository settings:

**Required Secrets**:

- `CLOUDFLARE_API_TOKEN`: Cloudflare API token with Workers edit permissions
- `CLOUDFLARE_ACCOUNT_ID`: Your Cloudflare account ID
- `GITHUB_CLIENT_ID`: OAuth client ID (production)
- `GITHUB_CLIENT_SECRET`: OAuth client secret (production)

**Optional Secrets** (per server):

- `ANTHROPIC_API_KEY`: For AI model integration
- `DATABASE_ENCRYPTION_KEY`: For encrypted storage
- `WEBHOOK_SECRET`: For webhook validation

## Security Considerations

### Never Commit OAuth Secrets

**Always add to `.gitignore`**:

```gitignore
# Local development secrets
.dev.vars
.env
.env.local
.env.*.local

# Wrangler local state
.wrangler/

# OAuth credentials
**/oauth-config.json
**/client-secrets.json
```

**Use environment variables and Wrangler secrets**:

```typescript
// ✅ Correct
export interface Env {
  GITHUB_CLIENT_SECRET: string;
}

export default {
  async fetch(request: Request, env: Env) {
    const secret = env.GITHUB_CLIENT_SECRET;
  }
};

// ❌ NEVER do this
const GITHUB_CLIENT_SECRET = "ghp_1234567890abcdef";
```

### Separate OAuth Apps for Dev/Production

**Development**:

- Callback URL: `http://localhost:8787/callback`
- Limited scope permissions
- Test client ID/secret in `.dev.vars`

**Production**:

- Callback URL: `https://your-worker.workers.dev/callback`
- Production scope permissions
- Production client ID/secret via `wrangler secret put`

**Never use production OAuth credentials in development**.

### CORS Configuration for Remote Access

```typescript
export default {
  async fetch(request: Request, env: Env): Promise<Response> {
    // Handle CORS preflight
    if (request.method === "OPTIONS") {
      return new Response(null, {
        headers: {
          "Access-Control-Allow-Origin": "*",
          "Access-Control-Allow-Methods": "GET, POST, OPTIONS",
          "Access-Control-Allow-Headers": "Content-Type, Authorization",
          "Access-Control-Max-Age": "86400"
        }
      });
    }

    // Process request
    const response = await handleRequest(request, env);

    // Add CORS headers to response
    response.headers.set("Access-Control-Allow-Origin", "*");
    return response;
  }
};
```

**Production**: Restrict CORS to specific origins:

```typescript
const allowedOrigins = ["https://claude.ai", "https://your-app.com"];

const origin = request.headers.get("Origin");
if (origin && allowedOrigins.includes(origin)) {
  response.headers.set("Access-Control-Allow-Origin", origin);
}
```

### Rate Limiting and Abuse Prevention

```typescript
import { RateLimiter } from "@cloudflare/workers-rate-limiter";

export default {
  async fetch(request: Request, env: Env): Promise<Response> {
    // Rate limit by IP address
    const clientIP = request.headers.get("CF-Connecting-IP") || "unknown";

    const limiter = new RateLimiter({
      namespace: env.RATE_LIMITER,
      limit: 100, // requests per window
      window: 3600 // 1 hour in seconds
    });

    const { success } = await limiter.limit(clientIP);

    if (!success) {
      return new Response("Rate limit exceeded", { status: 429 });
    }

    return handleRequest(request, env);
  }
};
```

**Per-user rate limiting with OAuth**:

```typescript
// Extract user ID from OAuth token
const userId = await extractUserIdFromToken(request);

// Apply per-user rate limit
const userLimiter = new RateLimiter({
  namespace: env.USER_RATE_LIMITER,
  limit: 1000, // higher limit for authenticated users
  window: 3600
});

const { success } = await userLimiter.limit(userId);
```

## Migration Checklist

### Converting Existing stdio MCP Servers to Remote

Use this checklist when migrating servers from local (stdio) to remote (SSE) deployment:

- [ ] **Transport Layer**
  - [ ] Replace `StdioServerTransport` with `SSEServerTransport`
  - [ ] Update server initialization to export fetch handler
  - [ ] Add `/sse` endpoint routing

- [ ] **Authentication**
  - [ ] Choose OAuth provider (GitHub, Google, Auth0, etc.)
  - [ ] Create development OAuth app
  - [ ] Create production OAuth app
  - [ ] Implement OAuth provider integration
  - [ ] Add user context to tool handlers

- [ ] **Configuration**
  - [ ] Create `wrangler.toml` in server directory
  - [ ] Configure environment variables
  - [ ] Set up `.dev.vars` for local development (add to .gitignore)
  - [ ] Document required secrets

- [ ] **Environment Variables**
  - [ ] Define `Env` interface with all variables
  - [ ] Add OAuth client ID/secret to environment
  - [ ] Configure Cloudflare bindings (KV, D1, R2) if needed
  - [ ] Set secrets via `wrangler secret put`

- [ ] **Build Configuration**
  - [ ] Update `package.json` scripts (dev, build, deploy)
  - [ ] Configure Bun build with `--target=browser`
  - [ ] Verify single-file bundle output
  - [ ] Test Workers compatibility (no Bun-only APIs)

- [ ] **Local Testing**
  - [ ] Start development server with `bun run dev`
  - [ ] Launch MCP Inspector
  - [ ] Connect to `http://localhost:8787/sse`
  - [ ] Test OAuth flow
  - [ ] Verify all tools work correctly
  - [ ] Test error handling

- [ ] **Deployment**
  - [ ] Build for production: `bun run build`
  - [ ] Deploy to Workers: `bunx wrangler deploy --env production`
  - [ ] Set production secrets
  - [ ] Verify deployment URL

- [ ] **Production Testing**
  - [ ] Test with MCP Inspector on production URL
  - [ ] Verify OAuth flow in production
  - [ ] Test all tools in production environment
  - [ ] Monitor logs with `bunx wrangler tail`

- [ ] **Client Configuration**
  - [ ] Configure Claude Desktop with `mcp-remote`
  - [ ] Configure Cursor MCP settings
  - [ ] Configure Windsurf (if applicable)
  - [ ] Test from each client application
  - [ ] Verify OAuth persistence across sessions

- [ ] **Security Audit**
  - [ ] Verify no secrets in source code
  - [ ] Confirm separate dev/prod OAuth apps
  - [ ] Review CORS configuration
  - [ ] Implement rate limiting
  - [ ] Add audit logging for sensitive operations
  - [ ] Test authorization checks

- [ ] **Documentation**
  - [ ] Update server README with remote deployment instructions
  - [ ] Document OAuth setup process
  - [ ] Add client configuration examples
  - [ ] Include troubleshooting guide

## Reference Examples

### Cloudflare Demo Repositories

**Without Authentication**:

- Repository:
  [cloudflare/ai/demos/remote-mcp-authless](https://github.com/cloudflare/ai/tree/main/demos/remote-mcp-authless)
- Template: `cloudflare/ai/demos/remote-mcp-authless`
- Use case: Public MCP servers, development/testing

**With GitHub OAuth**:

- Repository:
  [cloudflare/ai/demos/remote-mcp-github-oauth](https://github.com/cloudflare/ai/tree/main/demos/remote-mcp-github-oauth)
- Template: `cloudflare/ai/demos/remote-mcp-github-oauth`
- Use case: Production servers with authentication

### Existing Servers in Monorepo

**Priority for Migration**:

1. **Decision Framework** ([src/decision-framework](mdc:src/decision-framework))
   - High-value enterprise tool
   - Complex state management
   - Benefits from OAuth user context

2. **Memory** ([src/memory](mdc:src/memory))
   - Persistent knowledge graph
   - Multi-user scenarios
   - GDPR compliance requirements

3. **Collaborative Reasoning** ([src/collaborative-reasoning](mdc:src/collaborative-reasoning))
   - Multi-persona simulation
   - Team collaboration features
   - User-specific contexts

4. **Scientific Method** ([src/scientific-method](mdc:src/scientific-method))
   - Structured inquiry workflows
   - Shareable experiments
   - Cross-team research

### Common Patterns from Documentation

**Pattern 1: Simple Tool Server**

```typescript
// Minimal remote MCP server with one tool
export default {
  async fetch(request: Request): Promise<Response> {
    if (request.url.endsWith("/sse")) {
      const server = new Server({ name: "simple-tools", version: "1.0.0" });

      server.setRequestHandler(ListToolsRequestSchema, async () => ({
        tools: [{ name: "echo", description: "Echo input", inputSchema: { type: "object" } }]
      }));

      server.setRequestHandler(CallToolRequestSchema, async (req) => ({
        content: [{ type: "text", text: JSON.stringify(req.params.arguments) }]
      }));

      const transport = new SSEServerTransport("/messages", request);
      await server.connect(transport);
      return transport.response;
    }
    return new Response("Not Found", { status: 404 });
  }
};
```

**Pattern 2: OAuth-Protected Server**

```typescript
import { OAuthProvider } from "@modelcontextprotocol/server-oauth";

export default new OAuthProvider({
  apiRoute: "/sse",
  apiHandler: createMCPServer(),
  defaultHandler: GitHubHandler,
  authorizeEndpoint: "/authorize",
  tokenEndpoint: "/token",
  clientRegistrationEndpoint: "/register"
});
```

**Pattern 3: Multi-Environment Configuration**

```typescript
export default {
  async fetch(request: Request, env: Env): Promise<Response> {
    const isDevelopment = env.ENVIRONMENT === "development";

    // Different behavior based on environment
    const corsOrigin = isDevelopment ? "*" : "https://trusted-domain.com";

    // ... handle request
  }
};
```

## Resources

### Cloudflare Documentation

- **Remote MCP Server Guide**:
  [developers.cloudflare.com/agents/guides/remote-mcp-server](https://developers.cloudflare.com/agents/guides/remote-mcp-server/)
- **Testing Remote MCP Servers**:
  [developers.cloudflare.com/agents/guides/test-remote-mcp-server](https://developers.cloudflare.com/agents/guides/test-remote-mcp-server/)
- **MCP Authorization**:
  [developers.cloudflare.com/agents/model-context-protocol/authorization](https://developers.cloudflare.com/agents/model-context-protocol/authorization/)
- **Cloudflare Workers**: [developers.cloudflare.com/workers](https://developers.cloudflare.com/workers/)
- **Wrangler CLI**: [developers.cloudflare.com/workers/wrangler](https://developers.cloudflare.com/workers/wrangler/)

### MCP Protocol

- **MCP Specification**: [modelcontextprotocol.io](https://modelcontextprotocol.io/)
- **MCP Inspector**: [github.com/modelcontextprotocol/inspector](https://github.com/modelcontextprotocol/inspector)
- **Building MCP with LLMs**:
  [modelcontextprotocol.io/tutorials/building-mcp-with-llms](https://modelcontextprotocol.io/tutorials/building-mcp-with-llms)

### OAuth Provider Setup Guides

- **GitHub OAuth**:
  [docs.github.com/en/developers/apps/building-oauth-apps](https://docs.github.com/en/developers/apps/building-oauth-apps)
- **Google OAuth**:
  [developers.google.com/identity/protocols/oauth2](https://developers.google.com/identity/protocols/oauth2)
- **Auth0**: [auth0.com/docs/get-started](https://auth0.com/docs/get-started)
- **WorkOS**: [workos.com/docs/sso/guide](https://workos.com/docs/sso/guide)

### Related Rules

This rule complements:

- [cloudflare-workers.mdc](mdc:.cursor/rules/cloudflare-workers.mdc) - General Workers deployment patterns
- [mcp-protocol.mdc](mdc:.cursor/rules/mcp-protocol.mdc) - MCP protocol standards and server architecture
- [enterprise-standards.mdc](mdc:.cursor/rules/enterprise-standards.mdc) - Security, GDPR, and audit logging
- [bun-first.mdc](mdc:.cursor/rules/bun-first.mdc) - Bun development standards (adapt for Workers)
